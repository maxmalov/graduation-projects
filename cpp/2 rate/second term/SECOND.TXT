             Задачи практикума на ЭВМ для 2-го курса
                   II семестр 2008/2009 уч. г.


ТРЕБОВАНИЯ К ПРОГРАММАМ

  1. Все программы должны быть написано самостоятельно.

  2. Программы должны быть тщательно протестированы.

  3. Необходимо точно выполнять условия задач, при сомнениях --
     консультироваться с преподавателем. Программы представляются в
     исходных текстах.

  4. Текст программы должен быть откомментирован. В заголовке указать имя
     автора, группу, краткую формулировку задания. Переменные должны иметь
     осмысленные имена. Желательно объявление переменной снабжать
     комментарием о ее назначении.

  5. Следует структурировать программу, разбивая ее на (относительно)
     независимые части. Осуждается порочная практика размещения многих
     операторов в одной строке.

  6. Программы следует разбивать на модули, выделяя в заголовочные файлы 
     интерфейсную часть классов. Демонстрационная часть должна быть выделена
     в отдельный модуль.

  7. Интерфейс программы должен быть достаточно удобен для пользователя.

  8. Программа должна компилироваться без ошибок и предупреждений при всех
     включенных сообщениях компилятора.

  9. Перед сдачей программа должна быть хорошо протестирована.

  10. В программе не должно быть глобальных переменных.

  11. Классы должны содержать операторы ввода/вывода. 
      Классы, использующие динамическую память, должны содержать также
      следующие методы:
        o конструктор по умолчанию;
        o конструктор копии;
        o перегруженный оператор присваивания;
        o деструктор;

  12. Ошибки (ввода/вывода, нехватки памяти и проч.) должны корректно 
      обрабатываться программой, причем нужно реализовать "мягкую" обработку.
  13. Сроки сдачи программ:
	1-я -- до 1 марта,
	2-я -- до 1 апреля,
	3-я -- до 1 мая,
	4-я -- до конца семестра.


=============================================================================

  ------------------------------------------------------------------------
  I. Классы с динамической памятью.
  ------------------------------------------------------------------------


1. Реализовать класс "Стек символов" (на базе списка). 

Реализовать класс "Массив стеков". Длина массива определяется во время
инициализации и в дальнейшем не меняется. Массив должен хранить сами стеки,
а не указатели на них. Доступ к элементам массива осуществляется с помощью
квадратных скобок.

2. Реализовать класс "Очередь символов" (на базе списка).

Реализовать класс "Массив очередей". Длина массива определяется во время
инициализации и в дальнейшем не меняется. Массив должен хранить сами
очереди, а не указатели на них. Доступ к элементам массива осуществляется с помощью
квадратных скобок.

3. Реализовать класс "Дек символов" (на базе списка). 

Реализовать класс "Массив деков". Длина массива определяется во время
инициализации и в дальнейшем не меняется. Массив должен хранить сами деки,
а не указатели на них. Доступ к элементам массива осуществляется с помощью
квадратных скобок.

4. Реализовать класс "Матрица целых чисел" размера m x n. Класс должен включать 
в себя методы:

   * получить размеры матрицы;
   * получить элемент с заданными координатами;
   * изменить элемент с заданными координатами;
   * прибавить заданную матрицу;
   * умножить на заданную матрицу;
   * умножить на константу.

5. Реализовать класс "Защищенный массив символов". Массив должен быть
одномерным и индексироваться целыми числами. Границы изменения индекса
задаются при инициализации и в дальнейшем не изменяются. Методы: получить
границы массива, прочитать / изменить значение компоненты, вывести массив в
поток. При этом должна производиться проверка на нарушение границ, в случае
нарушения выводиться на экран сообщение об ошибке. Обращение к элементам
массива должно быть таким же, как и для обычных массивов.

Реализовать класс "Текст". Текст хранить в виде массива защищенных
массивов. Его максимальные размеры задаются во время инициализации и 
в дальнейшем не меняются. 
Методы: добавить строку в конец текста, 
прочитать/изменить строку с заданным номером,  удалить строку с заданным номером,
потоковый ввод/вывод текста.

6. Реализовать класс "Текст". Текст хранить в виде списка строк. Размеры
текста могут динамически изменяться. Методы:

   * добавить строку в начало текста
   * добавить строку в конец текста
   * добавить строку после n-й строки;
   * получить n-ю строку;
   * изменить n-ю строку;
   * удалить n-ю строку;
   * получить количество строк в тексте;
   * получить количество символов в тексте;
   * удалить весь текст.

Реализовать функцию, которая сравнивает два текста на равенство
(посимвольно).

7. Реализовать класс "Однонаправленный список символов". Класс должен
включать в себя методы:

   * стандартные методы списка
   * получение длины списка
   * вставить символ после i-го
   * удалить i-й символ
   * удалить первое вхождение заданного символа

Реализовать класс "Массив списков". Длина массива определяется во время
инициализации и в дальнейшем не меняется. 

8. Реализовать класс "Двунаправленный список символов". Класс должен
включать в себя методы:

   * стандартные методы списка
   * получение длины списка
   * вставить символ после i-го
   * удалить i-й символ
   * удалить первое вхождение заданного символа

Реализовать класс "Массив списков". Длина массива определяется во время
инициализации и в дальнейшем не меняется. Массив должен хранить сами
списки, а не указатели на них. 

  ------------------------------------------------------------------------
  II. Наследование
  ------------------------------------------------------------------------

11. Реализовать класс "Многочлен от переменных x,y,z с вещественными
коэффициентами" с методами:

   * вычисление значения многочлена на заданных числах;
   * вычисление степени многочлена по каждой переменной;
   * инициализация многочлена по строке.

Объект инициализируется символьной строкой, не содержащей скобок. На базе
этого класса реализовать иерархию производных классов:

1) "Многочлен от переменной x".  Новый метод:

   * вычисление производной многочлена (результат - новый многочлен).

2) "Квадратный трехчлен". Инициализация символьной строкой и тройкой чисел. 
Методы:

   * нахождение корней многочлена;
   * разложение многочлена на множители (результат - пара новых многочленов или
     признак того, что исходный многочлен неприводим).

3) "Квадратичные формы от переменных x,y,z". Инициализация только
символьной строкой. Методы:

   * форма диагональна или нет;
   * форма невырождена или нет.

12. Реализовать класс "Текст". Текст хранится в виде массива строк, длина
текста не фиксирована. Методы:

   * добавить строку в конец текста;
   * удалить последнюю строку;
   * текст пуст / непуст.

Реализовать также следующие классы (подумав, какой на базе какого):

1) "Объявление". Объявление представляет собой текст, имеет строку для
хранения адреса и массив строк с телефонами. Методы:

   * изменить адрес;
   * добавить / удалить телефон;
   * подсчитать количество символов в объявлении;
   * распечатать объявление (в поток).

2) "Объявления с вознаграждением". Представляет собой объявление с
информацией о сумме вознаграждения и методе, позволяющем ее получить.

3) "Доска объявлений". Содержит массив объявлений. Размер массива
определятся при инициализации и в дальнейшем не увеличивается. Методы:
добавление / чтение / удаление объявления;

13. Реализовать класс "Человек", включающий в себя имя, фамилию, отчество,
год рождения и методы, позволяющие изменять / получать значения этих полей.

Реализовать производные классы:

1) "Преподаватель университета" с полями: должность, ученая степень,
специальность, список научных трудов (массив строк).

2) "Член партии" с полями: название партии, год вступления в партию, номер
партбилета, автобиография (массив строк).

3) "Преподаватели - члены партии" (производный от 2 и 3). Дополнительное
поле -- список трудов в поддержку партии.

Классы должны содержать методы доступа и изменения всех полей. Предельные
размеры динамических массивов задаются при инициализации и не увеличиваются
в дальнейшем.

14. Реализовать класс "Человек", включающий в себя имя, фамилию, отчество,
год рождения и методы, позволяющие изменять / получать значения этих полей.

Реализовать производные классы:

1) "Предприниматель" -- содержит номер лицензии, адрес регистрации, ИНН,
данные о налоговых платежах (массив пар вида <дата, сумма>).

2) "Турист" -- содержит данные паспорта (строка), данные о пересечении
границы в виде массива пар <дата, страна>.

3) "Челнок" (производный от 2 и 3) -- добавляется массив строк - список
адресов, по которым покупается товар.

Классы должны содержать методы доступа и изменения всех полей. Предельные
размеры динамических массивов задаются при инициализации и не увеличиваются
в дальнейшем.

15. Описать абстрактный класс "Вещественнозначная функция" с методами:

  1. проверить, принадлежит ли число области определения функции;
  2. вычислить значение функции в точке;

Сделайте 3 класса-наследника для конкретных функций.

Описать класс "Функционал на функциях на отрезке [a,b]" с методом, аргумент
которого - указатель на "вещественнозначную функцию", результат -
вещественное число. Производные от "Функционала" классы должны реализовать
следующие функционалы:

  1. интегрирование методом прямоугольников (5-10 промежуточных значений);
  2. то же, методом трапеций;
  3. максимум модулей значений функции на концах отрезка и в середине.

Оболочка должна инициализировать объекты -- функции и функционалы и
распечатать значения заданного функционала на заданной функции.

16. Описать абстрактный класс "Функция на отрезке [a,b]" с методом, вычисляющим
значение функции в заданной точке и методами, позволяющими работать с
границами отрезка.

Реализовать производные классы

  1. полиномы 2-й степени одной переменной
  2. линейная комбинация тригонометрических функций sin и cos
  3. экспонента от полинома 1-й степени одной переменной
  4. константную функцию

17. "Матрицы"

Разработать базовый класс "Квадратная матрица вещественных чисел"
с методами чтения/записи элемента в заданную позицию, а также
операторами ввода/вывода.

От базового класса наследуются следующие классы:

(1) "Полная матрица вещественных чисел", хранящая n2 чисел.

(2) "Диагональная матрица вещественных чисел".

(3) "Верхнетреугольная матрица вещественных чисел".

От (3) наследуется:

(4) "Симметрическая матрица вещественных чисел".

Придумать оптимальный способ хранения каждого из четырех производных типов
матриц (так, для диагональных матриц не требуется квадратная таблица чисел).
Переопределить те методы, работа которых зависит от типа матрицы. 
Так, при попытке записать ненулевое число в позицию (3,1)
треугольной матрицы должна диагностироваться ошибка, при записи числа в
позицию (i,j) симметричной матрицы то же значение должно возникать в
позиции (j,i) и т.п.

18. Реализовать класс "Библиотечная карточка" с полями "автор", "название",
"количество страниц", "авторский знак", "инвентарный номер", 
"код по тематическому каталогу", а также методы доступа к ним.

Реализовать производные от него классы:

1) "Карточка для книги" с дополнительными полями "тираж", "год издания"
и "место издания".

2) "Карточка для журнала" с дополнительными полями
"год издания", "номер", "содержание" (в виде массива строк автор/название 
статьи).

3) "Карточка диссертации" с дополнительными полями "код специальности",
"место и год выполнения".

Реализовать класс "Каталог", позволяющий хранить карточки разных типов
(использовать механизм RTTI). Предусмотреть методы добавления, удаления 
карточек, возможность перебора всех карточек по-очереди, а также поиск 
карточек по автору + названию.

  ------------------------------------------------------------------------
  III. Шаблоны.
  ------------------------------------------------------------------------

21. Имеется необходимость работать с упорядоченными бинарными
деревьями поиска символов, строк и точек на плоскости (точка задается
своими координатами, считаем, что точка A(x,y) > B(x1,y1),
если x>x1 или (x=x1 и y>y1) ).
Разработайте набор классов, позволяющих работать с такими объектами.
Для деревьев предусмотреть методы: вставка и удаление элемента в дерево, вывод
дерева в поток в порядке убывания элементов, ввод из
потока, метод, возвращающий самый длинный путь в дереве в виде динамического
массива элементов.

22. Имеется необходимость работать с упорядоченными бинарными
деревьями поиска вещественных чисел, линейных многочленов  и двоичных строк.
Двоичная строка --- это строка из 0 и 1, их можно сравнивать
в лексикографическом порядке. Линейный многочлен ax+b меньше многочлена
cx+d, если пара <a,b>  меньше пары <c,d> в  лексикографическом порядке.
Разработайте набор классов, позволяющих работать с такими объектами.
Для деревьев предусмотреть методы: вставка и удаление элемента в дерево, вывод
дерева в поток по уровням (от корня к листьям), ввод из
потока, метод, возвращающий путь в дереве от корня к элементу x 
в виде динамического массива элементов.

23. Имеется необходимость работать с упорядоченными бинарными
деревьями поиска целых чисел, комплексных чисел и записей в телефонной книге.
Запись в телефонной книге содержит информацию о фамилии, имени, отчестве и 
номер телефона (длинное целое). Записи упорядочены  по ФИО абонентов. 
Комплексное число представляется в виде пары (модуль, аргумент),
считается, что z>z1, если |z|>|z1| или (|z|=|z1| и Arg z > Arg z1).
Разработайте набор классов, позволяющих работать с такими объектами.
Для деревьев предусмотреть методы: вставка и удаление элемента в дерево, вывод
дерева в поток в порядке возрастания элементов, ввод из
потока, оператор ==, определяющий, что деревья состоят из одних и тех же
элементов.

24. Имеется необходимость работать с упорядоченными бинарными
деревьями поиска символов, комплексных чисел и динамических массивов
целых чисел.
Комплексное число представляется в виде z=a+bi,
считается, что z>z1, если Re z > Re z1 или (Re z = Re z1 и Im z > Im z1).
Динамические массивы целых чисел можно сравнивать относительно
лексикографического порядка.
Разработайте набор классов, позволяющих работать с такими объектами.
Для деревьев предусмотреть методы: вставка и удаление элемента в дерево, вывод
дерева в поток по уровням (от листьев к корню), ввод из
потока, оператор <=, определяющий, является ли дерево T1 поддеревом
дерева T.


25. Имеется необходимость работать с упорядоченными бинарными
деревьями поиска вещественных чисел, троек  целых чисел и строк символов.
Тройки целых чисел и строки сравниваются относительно лексикографического 
порядка.
Разработайте набор классов, позволяющих работать с такими объектами.
Для деревьев предусмотреть методы: вставка и удаление элемента в дерево, вывод
дерева в поток по уровням (сперва корень, потом все потомки корня и т.п., 
последними --- листья), ввод из
потока, а также метод, позволяющий получить все листья дерева в виде
динамического массива элементов.


26. Дата --- это тройка чисел вида дд-мм-гг. Даты упорядочены 
естественным образом.
Имеется необходимость работать с упорядоченными бинарными
деревьями поиска целых чисел, строк символов и дат.
Разработайте набор классов, позволяющих работать с такими объектами.
Для деревьев предусмотреть методы: вставка и удаление элемента в дерево, вывод
дерева в поток по уровням (от листьев к корню), ввод из
потока, а также метод, позволяющий получить самый длинный путь в дереве
в виде динамического массива элементов (любой из таких путей, если их
несколько).

27. Библиотечная карточка содержит информацию об авторе книги,  название книги,
инвентарный номер книги (целое число). Карточки упорядочены по авторам 
(главный ключ) и названиям.  
Имеется необходимость работать с упорядоченными бинарными
деревьями поиска символов, троек из 0 и 1, библиотечных карточек.
Тройки из 0 и 1 сравниваются относительно лексикографического порядка.
Разработайте набор классов, позволяющих работать с такими объектами.
Для деревьев предусмотреть методы: вставка и удаление элемента в дерево, вывод
дерева в поток в порядке возрастания элементов, ввод из
потока, а также метод, удаляющий из дерева все листья.

28. Запись в адресной книге состоит из фамилии, имени и отчества и адреса.
Упорядочены такие записи по фамилии, имени и отчеству.
Время представляется тройкой чисел чч:мм:сс, такие тройки упорядочены 
естественным образом.
Имеется необходимость работать с упорядоченными бинарными
деревьями поиска целых чисел, времени, библиотечных карточек.
Разработайте набор классов, позволяющих работать с такими объектами.
Для деревьев предусмотреть методы: вставка и удаление элемента в дерево, вывод
дерева в поток в порядке убывания элементов, ввод из
потока, а также метод, позволяющий получить n-й уровень дерева в виде 
динамического массива элементов (нулевой уровень состоит из корневого 
элемента, первый --- все потомки корня, второй --- потомки потомков и т.д.).

  ------------------------------------------------------------------------
  IV. Сложные задачи
  ------------------------------------------------------------------------

31. МНОГОМЕРНЫЕ МАССИВЫ

Разработать класс, объектами которого являются многомерные массивы
(размерностью до MAX_DIM) с элементами типа NUMBER.

Конструктор класса выглядит примерно так:

Array::Array(int dim, ...); // первый параметр -- размерность,
// остальные параметры -- границы по соответствующей размерности.

Array M(3, 3,4,2); // пример создания массива размерности 3
// по 1-й размерности -- 3 (0..2),
// по 2-й размерности -- 4 (0..3),
// по 3-й размерности -- 2 (0..1).

Необходимы методы для определения размерности массива, величины массива по
данной размерности, сравнения двух многомерных массивов, базовые
арифметические операции:

   * сложение, вычитание двух массивов
   * умножение элементов массива на скаляр

Доступ к элементам массива осуществляется обычным образом:
M[2][0][1] = M[i][j][1] ;

При индексации проверяется выход за границы массива.

Результатом индексирования массива числом индексов K, где K<N и N -
размерность массива при конструировании, является многомерный массив
размерности N-K. Пример: Пусть задан двумерный массив M(3, 3,4,3), то
 M[1][2]    одномерный массив элементов
 M[1]       двумерный массив элементов
 M[1][2][2] элемент массива.

В тестовой задаче в качестве типа NUMBER можно использовать тип double.

32. ЛОГИКА ПРЕДИКАТОВ

Реализовать класс "Сигнатура формул логики предикатов". Символы 
сигнатуры обозначаются одной буквой. Нужно предусмотреть возможности:
  * получить тип символа (предикатный, функциональный, константный) 
по его обозначению;
  * получить местность символа;
  * добавить / удалить символ;
  * получить количество символов каждого типа;
  * проитерировать элементы сигнатуры;
  * сравнить две сигнатуры на равенство.

Реализовать класс "Формула логики предикатов". Внутреннее представление 
формулы -- дерево. Переменные обозначать одной буквой. Реализовать:
  * преобразование строка-формула и наоборот;

Реализовать класс "Конечная алгебраическая система" (конечной сигнатуры).
Элементы основного множества -- символы.
Предусмотреть методы:

  * получение мощности системы;
  * вычисление значения предиката / операции / константы на заданном наборе 
аргументов;
  * итератор, позволяющий перебрать элементы системы;
  * вычисление значения заданной формулы логики предикатов на наборе
элементов системы.


33. ЛОГИКА ВЫСКАЗЫВАНИЙ

Реализовать класс "Формула логики высказываний" (в предположении, что формулы
строятся с использованием только связок конъюнкция, дизъюнкция, импликация,
эквивалентность, отрицание, сложение по модулю 2, константы 0 и 1). 
Внутреннее представление формулы -- дерево.

Методы:

 * преобразование из строки во внутреннее представление и наоборот;
 * вычисление истинности при заданном наборе значений переменных;
 * приведение формулы к ДНФ;
 * приведение формулы к КНФ
(в двух последних результат -- новый объект).

Реализовать класс "Вывод методом резолюций", который для множества формул
Г и формулы Ф методом резолюций проверяет, выводится ли Ф из Г или нет.
Класс должен иметь методы, позволяющие получить сам вывод (т.е. КНФ всех
необходимых формул; список начальных дизъюнктов; список всех выводимых
дизъюнктов с указанием того, из каких дизъюнктов они выведены).



34. ДЛИННЫЕ ЧИСЛА

Реализовать два следующих класса.

1. Длинные целые числа.

Реализуйте класс, объектами которого являются целые числа с неограниченным
числом цифр. Число хранится в двоичном виде, память под массив данных
должна выделяться динамически.

Действия над длинными числами:

   * сложение, вычитание, умножение, деление нацело, взятие остатка,
     деление с остатком, возведение в целую степень;
   * операции сравнения двух длинных чисел;
   * ввод-вывод чисел (через потоки);
   * операции сдвига (на один/несколько бит);
   * взятие абсолютной величины числа.

Предусмотрите инициализацию числа строкой:
LongNumber N("123456789012345678901234567890");
N = "100000000000000000000000";
и преобразование числа в строку.

2. Рациональные числа.

Используя класс целых длинных чисел, реализовать арифметику рациональных
чисел. Рациональное число хранить в приведенном виде.

Действия над рациональными числами:

   * сложение, вычитание, умножение, деление нацело, взятие остатка,
     деление с остатком, возведение в целую степень;
   * операции сравнения двух длинных чисел;
   * ввод-вывод чисел (через потоки);
   * взятие абсолютной величины числа.

Предусмотрите инициализацию числа строкой:
Rational R("123456789012345678901234567890");
R = "100000000000000000000000.0000200001";
R = "1/7";

Оператор ввода из потока должен уметь читать число как в десятичном
представлении (123456789.0987654321), так и в виде дроби
(123456789/987654321). Оператор вывода печатает число в виде дроби.

Дополнительно предусмотреть преобразование числа в строку

а) в виде обычной дроби;

б) в виде десятичной дроби с заданным числом цифр в дробной части:
Rational r("2/3");
convertToDecimal( R, 4 ) == "0.6667"



35. МОДЕЛИРОВАНИЕ. "Волчий остров"

Остров (прямоугольник фиксированного размера) заселен дикими кроликами,
волками и волчицами. Имеется по несколько представителей каждого вида.
Кролики с вероятностью 1/9 передвигаются в один из восьми соседних
квадратов или остаются на прежнем месте. Каждый кролик с вероятностью 1/5
превращается в двух кроликов. Каждая волчица передвигается случайным
образом, пока в одном из восьми соседних квадратов не окажется кролик, за
которым она охотится. Если волчица и кролик оказываются в одном квадрате,
волчица съедает кролика и получает одно "очко". В противном случае она
теряет 0.1 "очка". Волки и волчицы c нулевым количеством "очков" умирают.
Волк ведет себя подобно волчице до тех пор, пока поблизости не исчезнут все
кролики; тогда если волчица находится в одном из восьми близлежащих
квадратов, волк гонится за ней. Если волк и волчица окажутся в одном
квадрате и там нет кролика, которого нужно съесть, они производят потомство
случайного пола.

Для создания более устойчивой экологической системы острова введите на
острове запретные зоны для хищников.

Разработать набор классов, реализующих данную программу.

Предусмотреть редактирование, сохранение на диске и восстановление с диска 
популяции, гибкое изменение параметров системы, пошаговую демонстрацию и 
режим быстрого просчета.



36. МНОЖЕСТВО С ХЭШ-ТАБЛИЦЕЙ

Реализовать класс-шаблон, объектами которого являются множества элементов с
элементами типа T (int, float, myObject, и т.д.) Для внутреннего
представления множества использовать динамическую хэш-таблицу.
Предполагается, что элемента типа Т можно сравнивать на равенство, кроме того
для элементов типа Т определен оператор int() преобразования в целое число.

Операции над множеством:

   * узнать мощность множества
   * добавить/удалить элемент
   * проверить есть ли элемент в множестве
   * сделать множество пустым
   * ввод/вывод множество в поток

Отношения между двумя множествами:

   * равны ли два множества
   * содержит ли одно множество другое
   * пересечение двух множеств
   * объединение двух множеств
   * разность двух множеств
   * симметрическая разность двух множеств

Реализовать класс "Итератор множества", который позволяет перебирать
элементы заданного множества. Порядок перебора элементов не фиксирован.
Набор методов итератора:

   * установить итератор в начальное состояние,
   * проверить: итератор перебрал все элементы множества,
   * выдать текущий элемент,
   * перейти к следующему элементу.

Пример:
myObject e(..);
SetOf S;
S.adjoinElement( e ); // добавить элемент e в S.

SetIterator Iter( S );
for( Iter.reset(); !Iter.done(); Iter.next() ) {
myObject tmp = I.value();
...
}

Рекомендуется сначала сделать обычные классы с типом элемента myObject, не
используя шаблоны. После того, как эти классы будут отлажены, можно
модифицировать их для использования шаблонов.


37. МНОЖЕСТВО НА БАЗЕ ДБ-ДЕРЕВА

1. Реализовать шаблонный класс "Двоичное Б-дерево" элементов типа Т
(описание двоичного Б-дерева смотри в книге Н.Вирта "Алгоритмы и 
структуры данных"). Предполагается, что элементы типа  Т  
можно сравнивать на равенство (==) и относительно некоторого порядка <. 

2. Реализовать шаблонный класс "Множество" элементов типа Т на базе двоичного 
Б-дерева.

Операции над множеством:

   * узнать мощность множества
   * добавить/удалить элемент
   * проверить есть ли элемент в множестве
   * сделать множество пустым
   * ввод/вывод множество в поток

Отношения между двумя множествами:

   * равны ли два множества
   * содержит ли одно множество другое
   * пересечение двух множеств
   * объединение двух множеств
   * разность двух множеств
   * симметрическая разность двух множеств

Реализовать класс "Итератор множества", который позволяет перебирать
элементы заданного множества. Порядок перебора элементов не фиксирован.
Набор методов итератора:

   * установить итератор в начальное состояние,
   * проверить: итератор перебрал все элементы множества,
   * выдать текущий элемент,
   * перейти к следующему элементу.

Пример:
myObject e(..);
SetOf S;
S.adjoinElement( e ); // добавить элемент e в S.

SetIterator Iter( S );
for( Iter.reset(); !Iter.done(); Iter.next() ) {
myObject tmp = I.value();
...
}

38. Б-ДЕРЕВО

Реализовать шаблонный класс "Б-дерево" элементов типа Т в предположении,
что все дерево помещается в оперативной памяти. Порялок дерева задается
при инициализации и не меняется. Для  элементов типа  Т  
определен оператор порядка < и сравнения на равенство ==.

Необходимо реализовать:
   * поиск элемента в дереве
   * вставка и удаление элемента
   * вывод дерева в поток в порядке возрастания элементов
   * ввод из потока
   * проверка дерева на пустоту
   * очистка дерева

